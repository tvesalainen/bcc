/*
 * Copyright (C) 2012 Timo Vesalainen
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.vesalainen.bcc;

import org.vesalainen.bcc.type.Descriptor;
import org.vesalainen.bcc.type.ClassWrapper;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import org.vesalainen.bcc.ConstantInfo.Clazz;
import org.vesalainen.bcc.ConstantInfo.ConstantDouble;
import org.vesalainen.bcc.ConstantInfo.ConstantFloat;
import org.vesalainen.bcc.ConstantInfo.ConstantInteger;
import org.vesalainen.bcc.ConstantInfo.ConstantLong;
import org.vesalainen.bcc.ConstantInfo.ConstantString;
import org.vesalainen.bcc.ConstantInfo.Fieldref;
import org.vesalainen.bcc.ConstantInfo.Methodref;
import org.vesalainen.bcc.ConstantInfo.NameAndType;
import org.vesalainen.bcc.ConstantInfo.Ref;
import org.vesalainen.bcc.ConstantInfo.Utf8;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;
import org.vesalainen.bcc.ConstantInfo.InterfaceMethodref;
import org.vesalainen.bcc.LocalVariableTable.LocalVariable;
import org.vesalainen.bcc.type.Generics;

/**
 * ClassFile wraps java classfile
 * @author tkv
 * TODO make thread safe
 */
public class ClassFile implements Writable
{
    /**
     * Declared public; may be accessed from outside its package.
     */
    public static final int ACC_PUBLIC = 0x0001;
    /**
     * Declared final; no subclasses allowed.
     */
    public static final int ACC_FINAL = 0x0010;
    /**
     * Treat superclass methods specially when invoked by the invokespecial instruction.
     */
    public static final int ACC_SUPER = 0x0020;
    /**
     * Declared synchronized; invocation is wrapped in a monitor lock
     */
    public static final int ACC_SYNCHRONIZED = 0x0020;
    /**
     * A bridge method, generated by the compiler
     */
    public static final int ACC_BRIDGE = 0x0040;
    /**
     * Declared with variable number of arguments.
     */
    public static final int ACC_VARARGS = 0x0080;
    /**
     * Declared native; implemented in a language other than Java
     */
    public static final int ACC_NATIVE = 0x0100;
    /**
     * Is an interface, not a class.
     */
    public static final int ACC_INTERFACE = 0x0200;
    /**
     * Declared abstract; must not be instantiated.
     */
    public static final int ACC_ABSTRACT = 0x0400;
    /**
     * Declared strictfp; ï¬‚oating-point mode is FP-strict
     */
    public static final int ACC_STRICT = 0x0800;
    /**
     * Declared synthetic; Not present in the source code.
     */
    public static final int ACC_SYNTHETIC = 0x1000;
    /**
     * Declared as an annotation type.
     */
    public static final int ACC_ANNOTATION = 0x2000;
    /**
     * Declared as an enum type.
     */
    public static final int ACC_ENUM = 0x4000;

    protected int magic;
    protected int minor_version;
    protected int major_version;
    private List<ConstantInfo> constant_pool = new ArrayList<>();
    protected int access_flags;
    protected int this_class;
    protected int super_class;
    private List<Short> interfaces = new ArrayList<>();
    private List<FieldInfo> fields = new ArrayList<>();
    private List<MethodInfo> methods = new ArrayList<>();
    private List<AttributeInfo> attributes = new ArrayList<>();

    protected Type superClass;
    protected Type thisClass;

    private Map<Integer,Object> constantMap = new HashMap<>();
    private Map<Class<? extends ConstantInfo>,List<ConstantInfo>> constantPoolMap = new HashMap<>();
    private Map<ConstantInfo,Integer> constantPoolIndexMap = new HashMap<>();
    
    protected ClassFile()
    {
    }
    public ClassFile(Class<?> cls) throws IOException
    {
        this(cls.getClassLoader().getResourceAsStream(cls.getName().replace('.', '/')+".class"));
    }

    public ClassFile(byte[] bytes) throws IOException
    {
        this(new ByteArrayInputStream(bytes));
    }

    public ClassFile(InputStream in) throws IOException
    {
        this(new DataInputStream(new BufferedInputStream(in)));
    }

    public ClassFile(File file) throws IOException
    {
        this(new DataInputStream(new BufferedInputStream(new FileInputStream(file))));
    }

    private ClassFile(DataInputStream oin) throws IOException
    {
        magic = oin.readInt();
        if (magic != 0xcafebabe)
        {
            throw new ClassFormatError();
        }
        minor_version = oin.readUnsignedShort();
        major_version = oin.readUnsignedShort();
        int constant_pool_count = oin.readUnsignedShort();
        for (int ii = 0; ii < constant_pool_count-1; ii++)
        {
            ConstantInfo ci = ConstantInfo.read(oin);
            addConstantInfo(ci);
            if (ci instanceof ConstantInfo.ConstantDouble || ci instanceof ConstantInfo.ConstantLong)
            {
                ii++;
            }
        }
        access_flags = oin.readUnsignedShort();
        this_class = oin.readUnsignedShort();
        super_class = oin.readUnsignedShort();
        int interfaces_count = oin.readUnsignedShort();
        for (int ii = 0; ii < interfaces_count; ii++)
        {
            interfaces.add((short) oin.readUnsignedShort());
        }
        int fields_count = oin.readUnsignedShort();
        for (int ii = 0; ii < fields_count; ii++)
        {
            fields.add(new FieldInfo(oin));
        }
        int methods_count = oin.readUnsignedShort();
        for (int ii = 0; ii < methods_count; ii++)
        {
            methods.add(new MethodInfo(this, oin));
        }
        int attributes_count = oin.readUnsignedShort();
        for (int ii = 0; ii < attributes_count; ii++)
        {
            attributes.add(AttributeInfo.getInstance(this, oin));
        }
        Clazz superClazz = (Clazz) getConstantInfo(super_class);
        superClass = ClassWrapper.fromInternalForm(getString(superClazz.getName_index()));
        Clazz clazz = (Clazz) getConstantInfo(this_class);
        thisClass = ClassWrapper.fromInternalForm(getString(clazz.getName_index()), superClass);
    }

    public Type getThisClass()
    {
        return thisClass;
    }

    public int getConstantPoolSize()
    {
        return constant_pool.size();
    }
    /**
     * Returns the constant map index to field
     * @param declaringClass
     * @param name
     * @param type
     * @return 
     */
    public int getFieldIndex(Type declaringClass, String name, Type type)
    {
        return getFieldIndex(declaringClass, name, Descriptor.getFieldDesriptor(type));
    }
    /**
     * Returns the constant map index to field
     * @param declaringClass
     * @param name
     * @param descriptor
     * @return
     */
    public int getFieldIndex(Type declaringClass, String name, String descriptor)
    {
        String fullyQualifiedForm = Generics.getFullyQualifiedForm(declaringClass);
        return getRefIndex(Fieldref.class, fullyQualifiedForm, name, descriptor);
    }
    /**
     * Returns the constant map index to method
     * @param clazz
     * @param methodName
     * @param descriptor
     * @param interf
     * @return
     */
    public int getMethodIndex(Member method)
    {
        Type declaringClass = method.getDeclaringClass();
        String fullyQualifiedname = Generics.getFullyQualifiedForm(declaringClass);
        return getRefIndex(Methodref.class, fullyQualifiedname, Generics.getName(method), Descriptor.getMethodDesriptor(method));
    }
    /**
     * Returns the constant map index to reference
     * @param refType
     * @param fullyQualifiedname
     * @param name
     * @param descriptor
     * @return
     */
    public int getRefIndex(Class<? extends Ref> refType, String fullyQualifiedname, String name, String descriptor)
    {
        String internalForm = ClassWrapper.getInternalForm(fullyQualifiedname);
        for (ConstantInfo ci : listConstantInfo(refType))
        {
            Ref mr = (Ref) ci;
            int classIndex = mr.getClass_index();
            Clazz clazz = (Clazz) getConstantInfo(classIndex);
            String cn = getString(clazz.getName_index());
            if (internalForm.equals(cn))
            {
                int nameAndTypeIndex = mr.getName_and_type_index();
                NameAndType nat = (NameAndType) getConstantInfo(nameAndTypeIndex);
                int nameIndex = nat.getName_index();
                String str = getString(nameIndex);
                if (name.equals(str))
                {
                    int descriptorIndex = nat.getDescriptor_index();
                    String descr = getString(descriptorIndex);
                    if (descriptor.equals(descr))
                    {
                        return constantPoolIndexMap.get(ci);
                    }
                }
            }
        }
        return -1;
    }
    /**
     * Returns the constant map index to name
     * @param name
     * @return
     */
    public int getNameIndex(String name)
    {
        for (ConstantInfo ci : listConstantInfo(Utf8.class))
        {
            Utf8 utf8 = (Utf8) ci;
            String str = utf8.getString();
            if (name.equals(str))
            {
                return constantPoolIndexMap.get(ci);
            }
        }
        return -1;
    }
    /**
     * Returns the constant map index to name and type
     * @param name
     * @param descriptor
     * @return
     */
    public int getNameAndTypeIndex(String name, String descriptor)
    {
        for (ConstantInfo ci : listConstantInfo(NameAndType.class))
        {
            NameAndType nat = (NameAndType) ci;
            int nameIndex = nat.getName_index();
            String str = getString(nameIndex);
            if (name.equals(str))
            {
                int descriptorIndex = nat.getDescriptor_index();
                String descr = getString(descriptorIndex);
                if (descriptor.equals(descr))
                {
                    return constantPoolIndexMap.get(ci);
                }
            }
        }
        return -1;
    }
    /**
     * Returns the constant map index to constant
     * @param constant
     * @return
     */
    public final int getConstantIndex(int constant)
    {
        for (ConstantInfo ci : listConstantInfo(ConstantInteger.class))
        {
            ConstantInteger ic = (ConstantInteger) ci;
            if (constant == ic.getConstant())
            {
                return constantPoolIndexMap.get(ci);
            }
        }
        return -1;
    }
    /**
     * Returns the constant map index to constant
     * @param constant
     * @return
     */
    public final int getConstantIndex(float constant)
    {
        for (ConstantInfo ci : listConstantInfo(ConstantFloat.class))
        {
            ConstantFloat ic = (ConstantFloat) ci;
            if (Float.compare(constant, ic.getConstant()) == 0)
            {
                return constantPoolIndexMap.get(ci);
            }
        }
        return -1;
    }
    /**
     * Returns the constant map index to constant
     * @param constant
     * @return
     */
    public final int getConstantIndex(double constant)
    {
        for (ConstantInfo ci : listConstantInfo(ConstantDouble.class))
        {
            ConstantDouble ic = (ConstantDouble) ci;
            if (Double.compare(constant, ic.getConstant()) == 0)
            {
                return constantPoolIndexMap.get(ci);
            }
        }
        return -1;
    }
    /**
     * Returns the constant map index to constant
     * @param constant
     * @return
     */
    public final int getConstantIndex(long constant)
    {
        for (ConstantInfo ci : listConstantInfo(ConstantLong.class))
        {
            ConstantLong ic = (ConstantLong) ci;
            if (constant == ic.getConstant())
            {
                return constantPoolIndexMap.get(ci);
            }
        }
        return -1;
    }
    /**
     * Returns the constant map index to constant
     * @param constant
     * @return
     */
    public final int getConstantIndex(String constant)
    {
        int nameIndex = getNameIndex(constant);
        for (ConstantInfo ci : listConstantInfo(ConstantString.class))
        {
            ConstantString ic = (ConstantString) ci;
            if (nameIndex == ic.getString_index())
            {
                return constantPoolIndexMap.get(ci);
            }
        }
        return -1;
    }

    public void addMethodInfo(MethodInfo methodInfo)
    {
        if (methods.contains(methodInfo))
        {
            throw new IllegalArgumentException("method "+methodInfo.getName_index()+" "+methodInfo.getDescriptor_index()+" exists already");
        }
        methods.add(methodInfo);
    }

    public void addFieldInfo(FieldInfo fieldInfo)
    {
        if (fields.contains(fieldInfo))
        {
            throw new IllegalArgumentException("field "+fieldInfo.getName_index()+" "+fieldInfo.getDescriptor_index()+" exists already");
        }
        fields.add(fieldInfo);
    }

    public List<FieldInfo> getFields()
    {
        return fields;
    }

    private boolean hasMethodInfo(MethodInfo methodInfo)
    {
        return methods.contains(methodInfo);
    }

    public List<MethodInfo> getMethodInfos()
    {
        return methods;
    }
    
    public String[] getArgNames(Member method)
    {
        MethodInfo methodInfo = getMethodInfo(method);
        if (methodInfo == null)
        {
            return null;
        }
        CodeAttribute codeAttribute = methodInfo.getCodeAttribute();
        if (codeAttribute == null)
        {
            return null;
        }
        LocalVariableTable localVariableTable = null;
        for (AttributeInfo ai : codeAttribute.getAttributes())
        {
            if (AttributeInfo.isOfType(this, "LocalVariableTable", ai))
            {
                localVariableTable = (LocalVariableTable) ai;
                break;
            }
        }
        if (localVariableTable == null)
        {
            return null;
        }
        List<LocalVariable> localVariables = localVariableTable.getLocalVariables();
        String[] args = new String[localVariables.size()];
        for (LocalVariable lv : localVariables)
        {
            args[lv.getIndex()] = getString(lv.getNameIndex());
        }
        return args;
    }

    public Type getClassName()
    {
        return thisClass;
    }

    public Type getSuperClassName()
    {
        return superClass;
    }

    public int getAccess_flags()
    {
        return access_flags;
    }

    public int getMajor_version()
    {
        return major_version;
    }

    public int getMinor_version()
    {
        return minor_version;
    }

    /**
     * Returns all classnames (in internal form) that this class references
     * @return
     */
    public SortedSet<String> getReferencedClassnames()
    {
        SortedSet<String> set = new TreeSet<String>();
        List<ConstantInfo> list = constantPoolMap.get(ConstantInfo.Clazz.class);
        if (list != null)
        {
            for (ConstantInfo ci : list)
            {
                ConstantInfo.Clazz cls = (Clazz) ci;
                int ni = cls.getName_index();
                String name = getString(ni);
                if (name.startsWith("["))
                {
                    for (int ii=1;ii<name.length();ii++)
                    {
                        if (name.charAt(ii) == 'L')
                        {
                            name = name.substring(ii+1, name.length()-1);
                            set.add(name);
                            break;
                        }
                    }
                }
                else
                {
                    set.add(name);
                }
            }
        }
        return set;
    }

    private int addConstantInfo(ConstantInfo ci)
    {
        return addConstantInfo(ci, constant_pool.size());
    }
    protected int addConstantInfo(ConstantInfo ci, int fromIndex)
    {
        List<ConstantInfo> rest = constant_pool.subList(fromIndex, constant_pool.size());
        int index = rest.indexOf(ci);
        if (index != -1)
        {
            return fromIndex+index+1;
        }
        constant_pool.add(ci);
        index = constant_pool.size();
        if (ci instanceof ConstantInfo.ConstantDouble || ci instanceof ConstantInfo.ConstantLong)
        {
            constant_pool.add(new ConstantInfo.Filler());
        }
        List<ConstantInfo> list = constantPoolMap.get(ci.getClass());
        if (list == null)
        {
            list = new ArrayList<>();
            constantPoolMap.put(ci.getClass(), list);
        }
        constantPoolIndexMap.put(ci, index);
        list.add(ci);
        return index;
    }
    
    protected void addWrapper(int index, Object wrapper)
    {
        constantMap.put(index, wrapper);
    }

    private List<ConstantInfo> listConstantInfo(Class<? extends ConstantInfo> cls)
    {
        List<ConstantInfo> list = constantPoolMap.get(cls);
        if (list == null)
        {
            list = new ArrayList<ConstantInfo>();
            constantPoolMap.put(cls, list);
        }
        return list;
    }
    public void addInterface(short intf)
    {
        interfaces.add(intf);
    }
    /**
     * Adds a new attribute
     * @param ai
     */
    public void addAttribute(AttributeInfo ai)
    {
        attributes.add(ai);
    }
    /**
     * Returns a wrapped element from constant map
     * @param index
     * @return
     */
    public Object getElement(int index)
    {
        Object ae = constantMap.get(index);
        if (ae == null)
        {
            throw new VerifyError("constant pool at "+index+" not proper type");
        }
        return ae;
    }
    /**
     * Returns the constant map index to field.
     * @param field
     * @return
     */
    public int getFieldIndex(Member field)
    {
        Type declaringClass = field.getDeclaringClass();
        String descriptor = Descriptor.getFieldDesriptor(field);
        int index = getFieldIndex(declaringClass, Generics.getName(field), descriptor);
        return index;
    }
    /**
     * Returns the constant map index to constructor
     * @param constructor
     * @return
     */
    public int getConstructorIndex(Member constructor)
    {
        return getMethodIndex(constructor);
    }
    /**
     * Returns a descriptor to method at index.
     * @param index
     * @return
     */
    public String getMethodDescription(int index)
    {
        ConstantInfo constantInfo = getConstantInfo(index);
        if (constantInfo instanceof Methodref)
        {
            Methodref mr = (Methodref) getConstantInfo(index);
            int nt = mr.getName_and_type_index();
            NameAndType nat = (NameAndType) getConstantInfo(nt);
            int ni = nat.getName_index();
            int di = nat.getDescriptor_index();
            return getString(ni)+" "+getString(di);
        }
        if (constantInfo instanceof InterfaceMethodref)
        {
            InterfaceMethodref mr = (InterfaceMethodref) getConstantInfo(index);
            int nt = mr.getName_and_type_index();
            NameAndType nat = (NameAndType) getConstantInfo(nt);
            int ni = nat.getName_index();
            int di = nat.getDescriptor_index();
            return getString(ni)+" "+getString(di);
        }
        return "unknown "+constantInfo;
    }
    /**
     * Returns a descriptor to class at index.
     * @param index
     * @return
     */
    public String getClassDescription(int index)
    {
        Clazz cz = (Clazz) getConstantInfo(index);
        int ni = cz.getName_index();
        return getString(ni);
    }
    /**
     * Returns MethodInfo or null.
     * @param method
     * @return 
     */
    public MethodInfo getMethodInfo(Member method)
    {
        String descriptor = Descriptor.getMethodDesriptor(method);
        int nameIndex = getNameIndex(Generics.getName(method));
        int descriptorIndex = getNameIndex(descriptor);
        for (MethodInfo mi : methods)
        {
            if (nameIndex == mi.getName_index() && descriptorIndex == mi.getDescriptor_index())
            {
                return mi;
            }
        }
        return null;
    }
    public boolean isImplemented(Member method)
    {
        MethodInfo methodInfo = getMethodInfo(method);
        return methodInfo != null;
    }
    /**
     * Return true if class contains method ref to given method
     * @param method
     * @return 
     */
    public boolean referencesMethod(Member method)
    {
        Type declaringClass = Generics.getDeclaringClass(method);
        String fullyQualifiedname = Generics.getFullyQualifiedForm(declaringClass);
        String name = Generics.getName(method);
        assert name.indexOf('.') == -1;
        String descriptor = Descriptor.getMethodDesriptor(method);
        return getRefIndex(Methodref.class, fullyQualifiedname, name, descriptor) != -1;
    }
    public boolean referencesClass(Type type)
    {
        return getClassIndex(type) != -1;
    }
    protected final int getClassIndex(Type type)
    {
        int index = -1;
        String name = Generics.getInternalForm(type);
        for (ConstantInfo ci : listConstantInfo(Clazz.class))
        {
            Clazz cls = (Clazz) ci;
            int nameIndex = cls.getName_index();
            String cn = getString(nameIndex);
            if (name.equals(cn))
            {
                index = constantPoolIndexMap.get(ci);
                break;
            }
        }
        return index;
    }
    /**
     * Return constantInfo at index.
     * @param index
     * @return
     */
    public final ConstantInfo getConstantInfo(int index)
    {
        return constant_pool.get(index-1);
    }
    /**
     * Return a constant string at index.
     * @param index
     * @return
     */
    public final String getString(int index)
    {
        Utf8 utf8 = (Utf8) getConstantInfo(index);
        return utf8.getString();
    }
    /**
     * Writes the class
     * @param out
     * @throws IOException
     */
    public void write(DataOutput out) throws IOException
    {
        out.writeInt(magic);
        out.writeShort(minor_version);
        out.writeShort(major_version);
        out.writeShort(constant_pool.size()+1);
        for (ConstantInfo ci : constant_pool)
        {
            ci.write(out);
        }
        out.writeShort(access_flags);
        out.writeShort(this_class);
        out.writeShort(super_class);
        out.writeShort(interfaces.size());
        for (int ii : interfaces)
        {
            out.writeShort(ii);
        }
        out.writeShort(fields.size());
        for (FieldInfo fi : fields)
        {
            fi.write(out);
        }
        out.writeShort(methods.size());
        for (MethodInfo mi : methods)
        {
            mi.write(out);
        }
        out.writeShort(attributes.size());
        for (AttributeInfo ai : attributes)
        {
            ai.write(out);
        }

    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)
    {
        try
        {
            File sample = new File("C:\\Users\\tkv\\Documents\\NetBeansProjects\\JavaLPG\\dist\\JavaLPG.jar");
            ClassFinder f = new ClassFinder(sample);
            ClassFile cf = f.find("org.vesalainen.parser.util.InputReader");
            FileInputStream fis = new FileInputStream(sample);
            byte[] code1 = new byte[(int)sample.length()];
            fis.read(code1);
            fis.close();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            DataOutputStream dos = new DataOutputStream(baos);
            cf.write(dos);
            dos.close();
            byte[] code2 = baos.toByteArray();
            if (code1.length != code2.length)
            {
                System.err.println("lengths differ");
            }
            else
            {
                for (int ii=0;ii<code1.length;ii++)
                {
                    if (code1[ii] != code2[ii])
                    {
                        System.err.println(ii+": "+code1[ii]+" <> "+code2[ii]);
                    }
                }
            }
            Class<?> cls = Class.forName("org.vesalainen.jvm.Sample");
            Field field = cls.getField("key1");
            Method method = cls.getMethod("test", Integer.TYPE);
            int index = cf.getFieldIndex(field);
            index = cf.getMethodIndex(method);
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
    }

}
