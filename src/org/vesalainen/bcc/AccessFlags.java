/*
 * Copyright (C) 2013 Timo Vesalainen
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.vesalainen.bcc;

import java.util.EnumSet;
import java.util.Set;
import javax.lang.model.element.Modifier;

/**
 * @author Timo Vesalainen
 */
public class AccessFlags 
{
    /**
     * Declared public; may be accessed from outside its package.
     */
    public static final int ACC_PUBLIC = 0x0001;
    /**
     * Declared private; accessible only within the defining class.
     */
    public static final int ACC_PRIVATE = 0x0002;
    /**
     * Declared protected; may be accessed within subclasses.
     */
    public static final int ACC_PROTECTED = 0x0004;
    /**
     * Declared final; no subclasses allowed.
     */
    public static final int ACC_FINAL = 0x0010;
    /**
     * Declared static.
     */
    public static final int ACC_STATIC = 0x0008;
    /**
     * Declared synchronized; invocation is wrapped in a monitor lock
     */
    public static final int ACC_SYNCHRONIZED = 0x0020;
    /**
     * A bridge method, generated by the compiler
     */
    public static final int ACC_BRIDGE = 0x0040;
    /**
     * Declared native; implemented in a language other than Java
     */
    public static final int ACC_NATIVE = 0x0100;
    /**
     * Declared abstract; must not be instantiated.
     */
    public static final int ACC_ABSTRACT = 0x0400;
    /**
     * Declared strictfp; ï¬‚oating-point mode is FP-strict
     */
    public static final int ACC_STRICT = 0x0800;
    /**
     * Declared synthetic; Not present in the source code.
     */
    public static final int ACC_SYNTHETIC = 0x1000;
    /**
     * Declared as an enum type.
     */
    public static final int ACC_ENUM = 0x4000;
    
    public static boolean isSynthetic(int flags)
    {
        return (flags | ACC_SYNTHETIC) != 0;
    }
    public static int getModifier(Set<Modifier> modifiers)
    {
        int flags = 0;
        for (Modifier m : modifiers)
        {
            flags |= getModifier(m);
        }
        return flags;
    }
    public static int getModifier(Modifier modifier)
    {
        switch (modifier)
        {
            case ABSTRACT:
                return ACC_ABSTRACT;
            case FINAL:
                return ACC_FINAL;
            case NATIVE:
                return ACC_NATIVE;
            case PRIVATE:
                return ACC_PRIVATE;
            case PROTECTED:
                return ACC_PROTECTED;
            case PUBLIC:
                return ACC_PUBLIC;
            case STATIC:
                return ACC_STATIC;
            case STRICTFP:
                return ACC_STRICT;
            case SYNCHRONIZED:
                return ACC_SYNCHRONIZED;
            default:
                throw new IllegalArgumentException(modifier+" is not valid method flag");
        }
    }
    public static void setModifiers(Set<Modifier> modifiers, int accessFlags)
    {
        if ((accessFlags & ACC_PUBLIC) != 0)
        {
            modifiers.add(Modifier.PUBLIC);
        }
        if ((accessFlags & ACC_PRIVATE) != 0)
        {
            modifiers.add(Modifier.PRIVATE);
        }
        if ((accessFlags & ACC_PROTECTED) != 0)
        {
            modifiers.add(Modifier.PROTECTED);
        }
        if ((accessFlags & ACC_STATIC) != 0)
        {
            modifiers.add(Modifier.STATIC);
        }
        if ((accessFlags & ACC_FINAL) != 0)
        {
            modifiers.add(Modifier.FINAL);
        }
        if ((accessFlags & ACC_SYNCHRONIZED) != 0)
        {
            modifiers.add(Modifier.SYNCHRONIZED);
        }
        if ((accessFlags & ACC_NATIVE) != 0)
        {
            modifiers.add(Modifier.NATIVE);
        }
        if ((accessFlags & ACC_ABSTRACT) != 0)
        {
            modifiers.add(Modifier.ABSTRACT);
        }
        if ((accessFlags & ACC_STRICT) != 0)
        {
            modifiers.add(Modifier.STRICTFP);
        }
    }
    public static class ClassFlags extends AccessFlags
    {
        /**
         * Treat superclass methods specially when invoked by the invokespecial instruction.
         */
        public static final int ACC_SUPER = 0x0020;
        /**
         * Declared with variable number of arguments.
         */
        public static final int ACC_VARARGS = 0x0080;
        /**
         * Is an interface, not a class.
         */
        public static final int ACC_INTERFACE = 0x0200;
        /**
         * Declared as an annotation type.
         */
        public static final int ACC_ANNOTATION = 0x2000;

    }
    public static class FieldFlags extends AccessFlags
    {
        /**
         * Declared volatile; cannot be cached.
         */
        public static final int ACC_VOLATILE = 0x0040;
        /**
         * Declared transient; not written or read by a persistent object manager.
         */
        public static final int ACC_TRANSIENT = 0x0080;

        public static int getModifier(Set<Modifier> modifiers)
        {
            int flags = 0;
            for (Modifier m : modifiers)
            {
                switch (m)
                {
                    case VOLATILE:
                        flags |= ACC_VOLATILE;
                        break;
                    case TRANSIENT:
                        flags |= ACC_TRANSIENT;
                        break;
                    default:
                        flags |= getModifier(m);
                        break;
                }
            }
            return flags;
        }
        public static void setModifiers(Set<Modifier> modifiers, int accessFlags)
        {
            AccessFlags.setModifiers(modifiers, accessFlags);
            if ((accessFlags & ACC_VOLATILE) != 0)
            {
                modifiers.add(Modifier.VOLATILE);
            }
            if ((accessFlags & ACC_TRANSIENT) != 0)
            {
                modifiers.add(Modifier.TRANSIENT);
            }
        }
    }
    public static class MethodFlags extends AccessFlags
    {
        /**
         * Declared with variable number of arguments.
         */
        public static final int ACC_VARARGS = 0x0080;

    }
}
